# 简介

本章为部分原创,和官网文档略有差异.

# 使用v-for指令来批量渲染

一个基本的`v-for`指令使用如下:

HTML:
```
<ul id="root">
    <li v-for="item in list">
        {{ item }}
    </li>
</ul>
```
JavaScript:
```
new Vue({
    el: '#root',
    data: {
        list:[1,2,3]
    }
})
```

__图片:输出内容:__  
![image text](Assets/cheaper-7-v-forbase.jpg)

__图片:DOM结构:__  
![image text](Assets/cheaper-7-v-forbaseDOM.jpg)

使用`v-for`指令可以迭代一个列表中的内容,迭代的次数取决于列表(数组)的长度.  
在上个例子中我们的数组长度为3,结果中就创建了3个`<p>`标签.

而`v-for="item in list"`中`list`就是需要被迭代的列表(数组),而`item`每次循环时候的具体内容.

## 迭代对象

上个例子中我们演示了`v-for`指令迭代一个列表(数组).

同样的`v-for`指令也可以迭代一个对象:

HTML:
```
<ul id="root">
    <li v-for="value in obj">
        {{ value }}
    </li>
</ul>
```
JavaScript:
```
new Vue({
    el: '#root',
    data: {
        obj:{
            firstWord:'hello',
            lastWord:'vue'
        }
    }
})
```
输出:
```
· hello
· vue
```

## 额外的参数

在JavaScript原生的数组迭代中有一个`forEach`方法,该方法有着如下的可选参数:
```
[1,2,3].forEach(function(value,index,array){
    // value == 每次循环时候元素的值
    // index == 当前循环的下标
    // array == 数组本身
})
```

`v-for`指令同样提供了上述参数,现在我们来尝试迭代一个**数组**:

HTML:
```
<ul id="root">
    <li v-for="(item,index) in list">
        {{ item +'--'+ index +'--'+ list }}
    </li>
</ul>
```
JavaScript:
```
new Vue({
    el: '#root',
    data: {
        list:['one','two','three']
    }
})
```

__图片:`v-for`迭代列表使用额外参数效果:__  
![image text](Assets/cheaper-7-v-listMore.jpg)

上例中:

- item == 元素本身
- index == 元素在数组中的下标

现在我们来尝试一下**对象**的语法:

HTML:
```
<ul id="root">
    <li v-for="(value,key,index) in obj">
        {{ key +'--'+ value +'--'+ index }}
    </li>
</ul>
```
JavaScript:
```
new Vue({
    el: '#root',
    data: {
        obj:{
            firstWrod:'hello',
            lastWord:'vue'
        }
    }
})
```

__图片:`v-for`迭代对象使用额外参数效果:__  
![image text](Assets/cheaper-7-v-listObjMore.jpg)

上例中:
- value == 对象的值
- key == 对象的键
- index == 当前循环的下标

# 特殊属性`key`

还记得第六章中条件渲染中的`key`属性吗,给元素指定一个不唯一的值,告诉Vue他们不是同一个元素来避免元素的复用.

在列表渲染中,也有`key`属性但是含义不同.

实际上这个属性是**必须传递**的,只是在上面的例子中为了简化没有提供.

## 为什么要使用key

> 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。`{1}`

- `{1}` 简单的来讲默认的情况下Vue不会去修改DOM来渲染改变后的列表.而是仅仅替换元素的属性或者内部的文本把它变成符合列表的样子.

> 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值：

```
<div v-for="item in items" :key="item.id">
  <!-- 内容 -->
</div>
```
> 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。

> 因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。

# 数组更新检测

这一章稍显复杂,但是关键的问题是**Vue有时候会在数据改变的时候获取不到更新**.  
一旦Vue获取不到数据的更新那么,也就无法进行响应式渲染.

总得来说,这个问题凸显在两个部分:
1. 运行时修改数组
2. 运行时添加属性

在下面的表格中,我列举了所有的修改**数组**的方法,并且给出了补救策略:
| 修改方法      | 描述             | 是否可以触发响应式 | 补救策略                                             |
| ------------- | ---------------- | ------------------ | ---------------------------------------------------- |
| [0] = 'xxx'   | 利用下标直接赋值 | 否                 | 使用Vue提供的Vue.set()                               |
| [].length='x' | 修改数组的length | 否                 | 同上或者使用vm.items.splice(newLength)               |
| [].push()     | 向数组添加内容   | 是                 |                                                      |
| [].pop()      | 获取数组的内容   | 是                 |                                                      |
| [].shift()    | 获取数组的内容   | 是                 |                                                      |
| [].unshift()  | 向数组添加内容   | 是                 |                                                      |
| [].splice()   | 切割或修改数组   | 是                 |                                                      |
| [].sort()     | 排序数组         | 是                 |                                                      |
| [].reverse()  | 反转数组         | 是                 |                                                      |
| [].filter()   | 过滤数组内容     | 否                 | 获取返回值然后重新赋值 vm.list = vm.list.filter(xxx) |
| [].concat()   | 连接多个数组     | 否                 | 同上                                                 |
| [].slice()    | 切割数组         | 否                 | 同上                                                 |

为了展示问题所在运行如下的例子:

HTML:
```
<ul id="root">
    <li v-for="item in list">
        {{ item }}
    </li>
</ul>
```
JavaScript:
```
var app = new Vue({
    el: '#root',
    data: {
        list:['hello','vue','!']
    }
});

console.log(app.list[0]); // 输出 hello

app.list[0] = 'world';

console.log(app.list[0]); // 输出 world
```

__图片:直接使用数组下标赋值后的效果:__  
![image text](Assets/cheaper-7-listindex.jpg)

可以看到即使我修改了数组的内容,但是Vue没有进行重新渲染.

下面的例子中,我们在执行的时候动态的给`data`中添加一个**属性**:

HTML:
```
<ul id="root">
    <p v-if="name">
        {{ name }}
        {{ age }}
    </p>
</ul>
```
JavaScript:
```
var app = new Vue({
    el: '#root',
    data: {
        name:''
    }
});

app.name = 'ASCll';
app.data.age = 20; // error
```
在这个例子中不仅仅`age`属性无法添加,甚至由于`age`不存在导致会报两次错误.

**补救办法**:使用`Vue.set()`.

<!-- TOOD 图片 -->

## 补救办法详解

### 1. Vue.set()方法的使用实例:

__Vue.set()是Vue的静态方法.__

该方法定义如下:
```
Vue.set( target, key, value )
```
| 键名   | 含义         |
| ------ | ------------ |
| target | 要修改的目标 |
| key    | 目标的键名   |
| value  | 对应键名的值 |

现在我们使用`Vue.set`修复上面**数组**例子中的问题:
```
var app = new Vue({
    el: '#root',
    data: {
        list:['hello','vue','!']
    }
});

console.log(app.list[0]); // hello

Vue.set(app.list,0,'world');

console.log(app.list[0]); // world
```

__图片:使用`Vue.set`后的结果:__  
![image text](Assets/cheaper-7-vuesetlist.jpg)

另外一个例子使用`Vue.set`修复上面**对象**例子中的问题:
```

```


## 不要和v-if联用
